# Coursework 2

Most students will use the same repository for coursework 2. You may use this file to present the results of that
coursework if you wish. Alternatively you can use video or audio to provide the explanations instead of writing them.

## **Requirements definition and analysis**

Requirements engineering is an iterative process in software engineering in which the expected capabilities of a finished product are discovered (or elicited), made more specific, validated and possibly changed. It plays an integral role in the development of a product, as these requirements come to shape the product goals which engineers, product managers and designers refer back to throughout development to ensure the product, once built, meets stakeholders' expectations. 

The innate complexity of software engineering projects is facilitated by the dividing up the work across different roles carried out by various team members. However, this "split" introduces complexities of its own such as fractionated progress due to individual interpretations of product goals. Requirements help manage this, as they ensure team members share a united perspective on the expectations of the finished product. This reduces project cost, as it mitigates the risk of building unsuccessful products.

 

### **Requirements identification methods**

The BABOK Guide (Business Analysis Body of Knowledge) provides a number of techniques that can be used to elicit requirements for software engineering projects. As a project is fundamentally underpinned by a need to serve users, they serve as the most useful source for discovering (or gathering) requirements.

Although the requirements identification methods available for this project are limited to solely brainstorming, if this were a real-world project, I believe focus groups, user interviews and observation would also be useful methods to undertake. (why??)

To ensure I gathered a diverse range of requirements through brainstorming, I followed divergent design thinking principles to arrive at a wealth of ideas. Here's a list of some of the basic requirement ideas I came up with:

1. Quick results
2. Accurate results
3. Ease of navigation from results to the actual movies (possibly via hyperlink)
4. Login/Create Account functionality
5. Users with accounts can save movie preferences
6. Users with accounts can indicate what movies they've watched already
7. Linked to Netflix rating system to adapt user recommendations


### **Requirement specification method**

After identifying a number of requirements, I formalised each of these into user stories. I chose this specification method as it uses natural language, thus ensuring widespread comprehensibility, and it goes even further by providing an insight into the rationale behind each user requirement, which the traditional "shall" natural language specification does not. User stories are also commonly used by Agile teams to specify requirements, so this method seemed appropriate given that this project is underpinned by the Data-driven Scrum methodology (which is an Agile framework). 
(more!! )

### **Prioritisation method**

To prioritise these, I considered a number of methods commonly adopted across software engineering and its related disciplines; namely the Harris Profile, the MoSCoW method and the 100-point method [(find here an exhaustive list of prioritisation methods, as documented in the design method toolkit by the Digital Society School)](https://toolkits.dss.cloud/design/).


### **Documented and prioritised requirements**

... (a table listing all the requirements in user stories, describing them as functional/non-functional, their category and whether they're a must, should, could or won't)

(a second, shortened table of just the musts and some shoulds)

### Validation

I validated my set of requirements against the following criteria:

| Requirement | Validity (Y/N) | Consistency (Y/N) | Completeness (Y/N) | Realism (Y/N) | Verifiability (Y/N) |
| --- | --- | --- | --- | --- | --- |
|  |  |  |  |  |  |
|  |  |  |  |  |  |
1. Validity - do they reflect the real, changing needs of the users?
2. Consistency - is there duplication or any contradictory constraints?
3. Completeness - do they include everything needed?
4. Realism - can they realistically be implemented in the technology, budget and time?
5. Verifiability - can they be tested?

Link to the full list of documented and prioritised requirements.


## Design
### Structure and flow of the interface

### Relational database design

### Application structure


## Testing
### Choice of unit testing library

### Tests
The tests should be in a separate and appropriately named file/directory.

### Test results
Provide evidence that the tests have been run and the results of the tests (e.g. screenshot).

### Continuous integration (optional)
Consider using GitHub Actions (or other) to establish a continuous integration pipeline. If you do so then please provide a link to the .yml and a screenshot of the results of a workflow run.

## Weekly progress reports

Copy and paste from Moodle or use the following structure. Delete this instruction text.

What I did in the last week:

- item
- item

What I plan to do in the next week:

- item
- item

Issues blocking my progress (state ‘None’ if there are no issues):

- item
- item

### Report 1

### Report 2

### Report 3

### Report 4

## References

Delete this instruction text before submitting:

- Include references to any templates you have used.
- If you justify any of your choices with references then remember to also include these.
- Use any [referencing style](https://library-guides.ucl.ac.uk/referencing-plagiarism/referencing-styles) that you are
  used to using in your course.
